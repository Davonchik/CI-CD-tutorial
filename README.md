# Введение в CI/CD (Continuous Integration / Continuous Delivery)

## Немного общей теории
**CI/CD** – это подход к разработке ПО, при котором рутинные процессы сборки, тестирования и развертывания автоматизированы. 

Процесс **CI/CD** часто называют **конвейером** **(pipeline)**, где исходный код на входе превращается в готовое приложение на выходе. Такой конвейер выступает в роли «робота-помощника», который берёт на себя скучные задачи: запускает тесты, собирает проект, выкладывает его на сервер. 

**Цель CI/CD** – ускорить и упростить доставку изменений в программном обеспечении, организуя высокое качество и надежность релизов.

**Рассмотрим схему:**

![alt text](image.png)

*На схеме показан бесконечный цикл CI/CD:*

Слева этапы **Continuous Integration: Code → Build → Test** — код пишется, автоматически собирается и проверяется.

Через мостик **Plan / Release** изменения переходят к **Continuous Delivery/Deployment (правая часть): Deploy → Operate → Monitor**. Здесь артефакт развёртывается, приложение работает в продакшене и непрерывно отслеживается. При полном непрерывном развертывании деплой на рабочий сервер выполняется автоматически сразу после успешных тестов и релиза.

## Непрерывная интеграция (CI) – Continuous Integration

**Continuous Integration (CI) или непрерывная интеграция** – практика разработки, при которой изменения в коде регулярно сливаются в общую кодовую базу и автоматически проверяются. Идея в том, чтобы интегрировать работу нескольких разработчиков как можно чаще, избегая «интеграционного ада», когда накопившиеся изменения трудно объединить.

Каждый коммит в репозиторий может запускать автоматическую сборку проекта, запуск линтеров, серию тестов и другое. Это позволяет сразу обнаружить, если новое изменение сломало сборку или тесты. 

Основные черты CI:
- Частое слияние кода – разработчики интегрируют изменения в основную ветку ежедневно (а то и несколько раз в день) ￼.
- Автоматическое тестирование – при каждом коммите запускаются юнит-тесты, линтеры и другие проверки качества кода ￼.
- Быстрая обратная связь – если сборка или тесты падают, команда узнаёт об этом сразу, а не спустя недели на этапе релиза ￼.

Цель непрерывной интеграции – убедиться, что после каждого изменения проект по-прежнему собирается и проходит тесты, то есть «ничего не сломалось» ￼. Это повышает уверенность в коде и позволяет находить и исправлять баги на ранней стадии разработки.

Непрерывная доставка и развёртывание (CD) – Continuous Delivery / Deployment

Continuous Delivery (CD) – непрерывная доставка – расширяет CI следующим шагом: после успешной интеграции и тестирования система автоматически подготавливает приложение к выпуску. Результатом может быть готовый артефакт (например, собранный исполняемый файл или контейнер с приложением), который потенциально готов к развёртыванию. Однако на этапе delivery обычно присутствует ручное одобрение перед выкаткой на продакшен ￼. Проще говоря, непрерывная доставка гарантирует, что код успешно прошёл все проверки и может быть развёрнут, когда будет принято решение о релизе.

Continuous Deployment – непрерывное развертывание – это следующий уровень автоматизации. Здесь обновление автоматически выкатывается на целевую среду (например, в продакшен) без ручного участия, сразу после прохождения всех тестов и проверок ￼. При правильно настроенном процессе deployment каждое изменение, прошедшее pipeline, сразу оказывается у пользователей.

Важно понимать разницу: непрерывная доставка обеспечивает автоматизацию вплоть до этапа готовности релиза, но оставляет финальное решение о выпуске человеку, тогда как непрерывное развёртывание устраняет этот ручной шаг, проводя деплой автоматически ￼ ￼. В обоих случаях сокращается время между написанием кода и получением этого кода пользователями.

Преимущества CD: Автоматизация доставки и деплоя позволяет выпускать обновления чаще и стабильнее. Ручных шагов меньше, значит, ниже риск ошибок и минимизируется время простоя при релизах ￼. Команда может быстрее получать обратную связь от пользователей и гибко реагировать на неё, что повышает качество продукта и удовлетворённость пользователей ￼.

GitHub Actions и Docker: пример CI/CD-пайплайна

Для реализации CI/CD существуют разные инструменты. В экосистеме GitHub встроенным решением является GitHub Actions – платформа автоматизации, позволяющая создавать CI/CD-конвейеры непосредственно в репозитории. GitHub Actions реагирует на события (push, pull request и др.) и выполняет заданные действия (build, test, deploy) по заранее описанному сценарию ￼ ￼.

Одним из важных инструментов в современных пайплайнах является Docker. Docker позволяет упаковать приложение и все его зависимости в стандартный контейнер, который можно запускать на любых серверах. Использование Docker вместе с CI/CD обеспечивает идентичную среду выполнения на всех этапах – от тестирования до продакшена. GitHub Actions и Docker отлично дополняют друг друга: Actions автоматизирует сборку и доставку, а Docker гарантирует, что приложение будет работать одинаково в разных окружениях ￼.

Пример сценария: представим веб-приложение с Dockerfile в репозитории. При каждом push в основную ветку запускается workflow, который выполняет следующие шаги:
	1.	Сборка образа Docker: GitHub Actions запускает сборку Docker-образа из Dockerfile (например, командой docker build или с помощью готового Action от Docker).
	2.	Тестирование: Можно запустить контейнер и прогнать внутри него тесты, либо выполнить отдельные шаги тестирования до/после сборки.
	3.	Публикация образа: После успешной сборки workflow может автоматически отправить (push) образ в контейнерный регистр, например Docker Hub или GitHub Container Registry.
	4.	Деплой: На этапе CD образ может быть развёрнут на сервере или в облаке. Например, GitHub Actions может подключиться к вашему серверу по SSH и запустить контейнер с новым образом.

Для всего этого в GitHub Actions уже есть готовые действия. Существует набор официальных Docker Action’ов – например, для входа в реестр (docker/login-action), для сборки и публикации образов (docker/build-push-action) и т.д. ￼ ￼. Эти действия переиспользуемы и упрощают интеграцию Docker в ваш pipeline.

Например, вместо написания вручную команд docker build и docker push, можно добавить шаг:

- uses: docker/build-push-action@v5
  with:
    context: .
    push: true
    tags: username/myapp:latest

В приведённом фрагменте используется готовый Action для сборки и отправки образа Docker. Вам достаточно указать контекст сборки (. – текущая директория с Dockerfile) и тег для образа. Подобным образом можно использовать docker/login-action для авторизации в Docker Hub перед публикацией образа, а затем, к примеру, Action appleboy/ssh-action для деплоя на свой сервер через SSH. Комбинация GitHub Actions и Docker позволяет полностью автоматизировать цепочку «код → контейнер → сервер» всего за несколько минут после каждого коммита.

YAML-конфигурация workflow: структура и основные элементы

Для описания CI/CD-конвейера в GitHub Actions используется YAML-файл (YAML – удобный текстовый формат разметки). Все файлы сценариев (workflow) хранятся в репозитории в каталоге .github/workflows/ ￼. В этих файлах задаётся структура пайплайна: когда запускать и что именно делать. Рассмотрим ключевые элементы YAML-конфигурации workflow:
	•	name: название workflow (необязательное поле). Например, name: CI Pipeline – удобное описание, которое будет отображаться во вкладке Actions.
	•	on: триггеры запуска. Секция on определяет, при каких событиях GitHub должен запустить этот workflow. Чаще всего указывают события репозитория: push, pull_request, а также можно задать фильтр по веткам или путям. Например:

on:
  push:
    branches: [ main ]

Этот триггер означает запуск конвейера при каждом пуше в ветку main ￼. Возможны и другие триггеры: по расписанию (schedule), при создании релиза, открытии issue и т.д. ￼ ￼.

	•	jobs: набор заданий (jobs), выполняющихся в рамках workflow. Каждый job – это логически отдельная задача, которая будет запущена на отдельном runner’е (виртуальной машине или контейнере). Джобы определяются как вложенные секции внутри jobs. Можно настроить один job или несколько. По умолчанию несколько jobs выполняются параллельно, но можно задать зависимости (параметр needs) для последовательного выполнения.
	•	runs-on: среда выполнения для job. Например, runs-on: ubuntu-latest означает, что GitHub предоставит Linux-окружение (последнюю версию Ubuntu) для запуска шагов этого job. Доступны различные образы runner’ов: ubuntu, windows, macOS, а также можно использовать self-hosted runner (свой сервер).
	•	steps: шаги, из которых состоит job. Шаги выполняются последовательно внутри одного job и, как правило, включают либо вызов Action, либо выполнение shell-команды. Каждый шаг можно снабдить именем (- name: Install dependencies) для наглядности.
	•	actions: действия, которые можно использовать в шагах. Action – это повторно используемый скрипт или команда, оформленные как готовый компонент. Например, официальное действие actions/checkout@v3 выполняет команду git checkout вашего репозитория на runner, а actions/setup-node@v3 может установить среду Node.js нужной версии. В YAML файл шаг с использованием действия выглядит так: - uses: actions/checkout@v3. Использование готовых actions позволяет не писать рутинный код самому ￼.

Простая структура файла workflow может выглядеть так (пример из документации GitHub Actions):

name: Simple CI

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: echo "Hello, GitHub Actions!"

В этом примере workflow с именем “Simple CI” запускается при пуше в ветку main. Он содержит один job build, который выполняется на Ubuntu-раннере и состоит из двух шагов: первый использует готовое действие для получения кода репозитория, второй – выполняет shell-команду вывода текста. При пуше в main этот конвейер автоматически запустится, что можно наблюдать во вкладке Actions на GitHub ￼.

Обратите внимание: YAML чувствителен к отступам – структура определяется отступами пробелов. В репозитории вы можете создавать несколько workflow-файлов для разных целей (например, отдельный workflow для тестов и отдельный для деплоя) ￼.

Преимущества автоматизации через CI/CD

Внедрение CI/CD дает существенные преимущества команде разработки и качеству продукта:
	•	Быстрое выявление ошибок. Автоматические тесты на каждом коммите позволяют сразу обнаружить проблемы. Это предотвращает ситуацию, когда баги копятся и всплывают поздно – на этапе релиза или в продакшне ￼. Чем раньше найдена и исправлена ошибка, тем дешевле это обходится.
	•	Стабильность сборок. Конвейер гарантирует повторяемость сборки в стандартном окружении. Исключается фактор “на моей машине работает”: среда для сборки и тестов унифицирована (особенно при использовании Docker-контейнеров). Если код прошёл через CI, с высокой вероятностью он будет корректно работать и в последующих средах.
	•	Быстрая доставка изменений. Автоматизация сокращает время между написанием кода и его развертыванием. Частые интеграции и поставки означают, что новые функции и исправления быстрее доходят до пользователей. Это даёт конкурентное преимущество и позволяет чаще собирать обратную связь.
	•	Меньше ручной рутины. Разработчикам и инженерам по развертыванию не нужно тратить время на повторяющиеся операции сборки, тестирования, деплоя. Рутинные задачи за них делает CI/CD-система. Это снижает вероятность человеческих ошибок и освобождает время для более творческих задач.
	•	Постоянный мониторинг качества. CI/CD-конвейер можно расширить статическим анализом кода, проверками стиля, безопасности и другими качественными метриками. Код проверяется автоматически при каждом изменении, что поддерживает высокий стандарт качества проекта.
	•	Прозрачность процесса. Статус сборок и деплоев всегда виден команде: кто угодно может зайти во вкладку Actions (или Pipelines) и увидеть, какие сборки прошли, а какие упали и по каким причинам. Это улучшает сотрудничество в команде – проблемы видны сразу и их можно обсуждать открыто.

В итоге CI/CD внедряет культуру «непрерывного улучшения»: команда поставляет изменения небольшими порциями, но часто. Это снижает риски, упрощает отладку и делает релизы менее стрессовыми.

Полезные советы для начинающих внедрять CI/CD

Ниже приведены дополнительные рекомендации для студентов, начинающих знакомство с CI/CD и DevOps-подходами. Эти советы помогут эффективно использовать конвейеры непрерывной интеграции и доставки:
	•	Следите за статусом сборок. После каждого пуша проверяйте, что ваш workflow действительно запустился и завершился успешно. В GitHub это можно увидеть во вкладке “Actions” (зелёная галочка – успех, красный крестик – ошибка) ￼. Регулярно просматривайте статус, чтобы сразу замечать сбои.
	•	Разбирайте логи при сбоях. Если pipeline падает, ваши главные помощники – логи. Изучите вывод шагов, чтобы понять, на каком этапе произошла ошибка и что именно пошло не так ￼. В GitHub Actions при клике на конкретный job можно увидеть подробный лог выполнения каждой команды.
	•	Исправляйте ошибки быстро. Одно из достоинств CI/CD – быстрая обратная связь. Как только обнаружили ошибку в сборке, постарайтесь оперативно внести исправления и снова запустить конвейер (просто отправив новый коммит) ￼. Через несколько минут вы узнаете, решена ли проблема. Такой цикл позволяет не откладывать решение проблем в долгий ящик.
	•	Не бойтесь экспериментировать. Попробуйте намеренно сломать тест или сделать ошибку, чтобы увидеть, как реагирует CI-система ￼. Добавляйте новые шаги в workflow, например автоматическую проверку кода линтером или сборку документации. Практические эксперименты помогут лучше понять работу CI/CD и избавиться от страха что-либо сломать.
	•	Используйте готовые решения. Не изобретайте велосипед с нуля. В библиотеке GitHub Marketplace множество готовых actions для типичных задач (деплой на различные платформы, публикация пакетов, обновление Docker Hub и пр.) ￼ ￼. Аналогично, GitLab CI предлагает шаблоны и примеры. Пользуйтесь этими ресурсами – это сэкономит время и убережёт от ошибок, которые уже решены сообществом.
	•	Усложняйте постепенно. Начните с самого простого конвейера (например, запуск тестов на каждый пуш) и убедитесь, что он стабильно работает. Затем шаг за шагом добавляйте новые этапы: больше тестов, сборку Docker-образов, деплой на тестовый сервер и т.д. ￼. Такой поэтапный подход позволит плавно внедрять CI/CD и учиться на каждом этапе, не создавая избыточной сложности сразу.

Следуя этим рекомендациям, вы выстроите надёжный процесс CI/CD, который станет неотъемлемой частью разработки. Помните, что CI/CD – это не разовая настройка, а постоянно совершенствуемый процесс. Начав с малого и получив первые успехи (пусть даже небольшой workflow с выводом “Hello, World”), вы сделаете важный шаг к DevOps-культуре и непрерывному совершенствованию своего проекта. Успехов в автоматизации!

Источники и дальнейшее чтение:
	•	Stanislav Grosman. «CI/CD на GitHub Actions и GitLab CI для самых маленьких. Часть 1» – основы CI/CD, понятия Workflow, Job, Step, Action ￼ ￼.
	•	Red Hat. “What is CI/CD?” – обзор значимости CI/CD, различия между Continuous Delivery и Deployment ￼ ￼.
	•	Docker Docs. “Docker Build GitHub Actions” – официальный набор GitHub Actions для работы с Docker (сборка и публикация образов) ￼.
	•	RunCloud. “How to Build a CI/CD Pipeline with GitHub Actions and Docker” – пример построения контейнерного CI/CD-пайплайна: автоматическая сборка Docker-образа, пуш в регистр и деплой на сервер ￼.
	•	Habr (@grosm4n). «CI/CD… Часть 2» – практическое руководство по созданию первого workflow и советы для начинающих ￼ ￼.
